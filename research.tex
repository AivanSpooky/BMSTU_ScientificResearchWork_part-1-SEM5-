\chapter{Анализ существующих методов \\решения ЗК}

\section{Формализация задачи}
Пусть задан взвешенный полный граф
\begin{equation}
    \label{eq:graph}
    G = (V, E),
\end{equation}
где $V = \{1, 2, ..., n\}$ --- множество вершин (городов), а $E$ --- множество ребер. Каждому ребру $(i, j) \in E$ соответсвует стоимость (расстояние) $c_{ij}$. Необходимо найти такую перестановку городов $\pi = (\pi_{1}, \pi_{2}, ..., \pi_{n})$, что функционал
\begin{equation}
    \label{eq:func}
    f(\pi) = \sum_{k=1}^{n-1}{c_{\pi_{k}\pi_{k+1}}+c_{\pi_{n}\pi_{1}}},
\end{equation}
минимален.

\section{Точные методы}
Точные методы решения ЗК в значительной степени условно подразделяются на методы: полного перебора, динамического программирования, ветвей и границ, множителей Лагранжа, отсекающих плоскостей, композитные, прочие.
Эффективные алгоритмы точного решения ЗК, разработанные в последние годы, как правило, принадлежат к разряду композитных, т. е. содержат в себе элементы нескольких методов, и выделение «чистых стратегий» имеет в основном методологическую ценность [5].

\subsection{Метод полного перебора}
Полный перебор заключается в поиске решения путем перебора всевозможных вариантов решения, и отыскания среди этих вариантов удовлетворяющего заданным требованиям.

Достоинство данного метода --- точность результата. Метод полного перебора всегда определяет оптимальный Гамильтонов цикл в графе.

Главный недостаток --- количество времени, необходимое для отыскания всевозможных вариантов решения,
которое растет вместе с увеличением количества $n$ вершин графа, что может потребовать для поиска решения количество времени, несравнимое с человеческой жизнью. Поскольку коммивояжер в каждом из городов встает перед выбором следующего города из тех, что он еще не посетил, существует $(n-1)!$ маршрутов для асимметричной и $\frac{(n-1)!}{2}$ маршрутов для симметричной задачи коммивояжера.

\subsection{Метод динамического программирования}
Метод динамического программирования был практически одновременно предложен вместе с методом полного перебора [6].
Пусть $|V|=n$, $|E|=m$. Элементы $c_{ii}= \infty, i=\overline{1,n}$. Начальной вершиной маршрута коммивояжера будем считать вершину 1. Пусть $S \subseteq V$ --- некоторое подмножество вершин. Обозначим через $f(S, j)$ длину минимальной элементарной цепи, начинающейся в вершине 1, проходящей через все вершины из $S$ и заканчивающейся в вершине $j \in S$. Тогда из принципа оптимальности Беллмана [7] имеем следующее функциональное уравнение: 
\begin{equation}
    \label{eq:func1}
    f(S, j) = \min_{i\in S\diagdown j}{\{c_{ij}+f(S\diagdown j, i)\}}
\end{equation}
с начальными условиями
\begin{equation}
    \label{eq:func2}
    f(\varnothing,\varnothing) = 0.
\end{equation}
На последнем шаге~ref{eq:func1} переходит в
\begin{equation}
    \label{eq:func2}
    f^* = \min_{i\in V\diagdown 1}{\{c_{i1}+f(V, i)\}},
\end{equation}
где $f^*$ --- длина оптимального тура.

Главное достоиство --- метод не чувствителен к введению дополнительных ограничений. В [8] метод был использован для решения ЗК с выбором (задача 1.5.6). В [9] метод был использован для решения ЗК с выделенными вершинами (задача 1.5.6), а в [10] --- для решения ЗК с взаимодействующими парами пунктов (задача 1.15.13).

Главным недостатком метода является чрезмерное количество вычислений и требований к памяти (требуется около $\sqrt{n}\cdot2^n$ ячеек). Трудоемкость данного алгоритма оценивается как $O(n^2\cdot2^n)$. При этом в иной схеме метода динамического программирования [11] удается сократить количество ячеек до ~$n$, однако при этом объем вычислений возрастает до $O(4^n)$ операций. 

% \begin{itemize}[label=---]
%     \item <<распознавание с учителем>> --- заключается в том, что данные предописываются тем, кто проводит исследование, то есть размечаются по какому-либо принципу;
%     \item <<распознавание без учителя>> --- модель обучается на данных, которые не были предварительно обработаны, таким образом модели приходится самой выделять полезные признаки из изображения.
% \end{itemize}
\subsection{Метод ветвей и границ}
Метод ветвей и границ --- это общий подход к решению сложных комбинаторных задач оптимизации, в том числе задачи коммивояжера. Он основан на построении дерева решений, в узлах которого рассматриваются подзадачи с постепенно уточняющимися ограничениями. Метод позволяет отсекать (не рассматривать) ветви дерева, заведомо не приводящие к оптимальному решению, на основе вычисляемых оценок снизу (нижних границ целевой функции).

Основными элементами метода ветвей и границ являются:
\begin{enumerate}
    \item Оценивание снизу. Способ вычисления нижней оценки для множества решений.
    \item Оценивание сверху. Способ вычисления приближенного решения ЗК.
    \item Разбиение. Способ разбиения множества решений на подмножества, то есть способ формирования списка подзадач.
    \item Ветвление. Порядок выбора очередной подзадачи из списка подзадач.
    \item Отсечение. Правило отбрасывания бесперспективных элементов множества решений.
\end{enumerate}

Схема метода ВГ представлена на рисунке~\ref{img:methodVG}\clearpage
\imgScale{0.8}{methodVG}{Схема метода ветвей и границ}
\begin{enumerate}
    \item Построение матрицы с исходными данными: в таблицу заносятся расстояния ($c_{ij}$) между городами (в ячейки типа A-A, B-B и т. д. ставится $\infty$ --- условно бесконечно большое число); при этом строкам соответствуют города отбытия, а столбцам города прибытия;
    \item Нахождение минимумов по строкам: в каждой строке определяется минимальное число ($d_{i}$) и выписывается в отдельный столбец;
    \item Редукция строк: из значений ячеек каждой строки вычитаем соответствующий минимум ($c_{ij} = c_{ij} — d_{i}$), не затрагивая при этом клетки с $\infty$;
    \item Приведение столбцов: аналогично строкам, из каждого столбца вычитается его минимум. Сумма всех вычтенных элементов дает нижнюю границу маршрута в корне дерева.
    \item Выбор нулевой клетки: для каждой нулевой клетки оцениваем, насколько выгодно включение соответствующего ребра. Выбираем клетку с максимальной оценкой.
    \item Ветвление: рассматриваем два варианта — с включением и без включения данного ребра. Для ветви включения вычеркиваем строку и столбец выбранной клетки, запрещаем обратный путь. Для ветви исключения ставим в нее $\infty$.
    \item Пересчет нижних границ: пересчитываем нижние границы для обоих вариантов и выбираем для продолжения ту ветвь, где нижняя граница меньше.
    \item Повторение шага: продолжаем ветвление и приведение до тех пор, пока не будет определен полный маршрут. Итоговая длина маршрута вычисляется по исходной матрице.
\end{enumerate}
\imgScale{0.7}{vetvGran}{Пример работы алгоритма ветвей и границ}

Главное достоинство метода ветвей и границ --- он гарантированно находит оптимальное решение, если рассмотреть все ветви без отсечения перспективных вариантов.

Главный недостаток метода ветвей и границ --- в худшем случае он требует экспоненциального времени, порядка $2^n$ вычислений, поскольку даже с отсечениями при увеличении размера задачи число вариантов все еще может быть велико.

\subsection{Метод множителей Лагранжа}
Метод множителей Лагранжа (или лагранжева релаксация) для задачи коммивояжера заключается в том, что часть ограничений задачи переносится в целевую функцию с помощью соответствующих множителей (лагранжевых коэффициентов).

Задача коммивояжера может быть сформулирована как целочисленная задача линейного программирования (ЦЛП). Введем бинарные переменные:
\begin{equation}
x_{ij} = \begin{cases} 
1, & \text{если дуга $(i,j)$ входит в маршрут;} \\[6pt]
0, & \text{иначе.}
\end{cases}
\end{equation}

Стандартная ЦЛП-формулировка задачи коммивояжера:
\begin{equation}
\min \sum_{i \in V} \sum_{j \in V, j \neq i} c_{ij} x_{ij}
\end{equation}
при условиях
\begin{equation}
\sum_{j \in V, j \neq i} x_{ij} = 1 \quad \forall i \in V,
\end{equation}
\begin{equation}
\sum_{i \in V, i \neq j} x_{ij} = 1 \quad \forall j \in V,
\end{equation}
\begin{equation}
x_{ij} \in \{0,1\}.
\end{equation}

Кроме этого, чтобы исключить подтуры (циклы, не охватывающие все вершины), 
вводятся подтуровые ограничения (например, неравенства типа MTZ или SЕC) [12]:
\begin{equation}
\sum_{i \in S}\sum_{j \in S} x_{ij} \le |S|-1 \quad \forall S \subset V, 2 \le |S| \le n-1.
\end{equation}

Эти подтуровые ограничения делают решение задачи значительно сложнее. 
В методе множителей Лагранжа (лагранжевой релаксации) некоторые из сложных 
ограничений переносятся в целевую функцию с помощью множителей Лагранжа 
$\lambda_S \geq 0$ для каждого подмножества $S$:
\begin{equation}
L(\lambda) = \min_{x} \left\{ \sum_{i}\sum_{j \neq i} c_{ij}x_{ij} 
+ \sum_{2 \le |S| \le n-1} \lambda_S \left( \sum_{i \in S}\sum_{j \in S} x_{ij} -(|S|-1)\right) \right\}.
\end{equation}
%S \subset V,

Таким образом, релаксируем подтуровые ограничения:
\begin{equation}
\sum_{i \in S}\sum_{j \in S} x_{ij} \le |S|-1 \implies \sum_{i \in S}\sum_{j \in S} x_{ij} -(|S|-1) \le 0.
\end{equation}

Подставляя их в целевую функцию с лагранжевыми множителями, получаем:
\begin{equation}
L(\lambda) = \min_{x} \left\{ \sum_{i}\sum_{j \neq i} \tilde{c}_{ij}(\lambda) x_{ij}\right\},
\end{equation}
где
\begin{equation}
\tilde{c}_{ij}(\lambda) = c_{ij} + \sum_{S: i,j \in S} \lambda_S.
\end{equation}

Здесь $\tilde{c}_{ij}(\lambda)$ — модифицированные (скорректированные) стоимости дуг, 
учитывающие штрафы за нарушение подтуровых ограничений.

\textbf{Суть метода}: найти такой вектор множителей Лагранжа $\lambda = (\lambda_S)$, 
чтобы значение $L(\lambda)$ давало как можно более сильную нижнюю оценку на исходную задачу. 
Для этого часто применяют субградиентные методы:
\begin{equation}
\lambda_S^{(k+1)} = \max\{0, \lambda_S^{(k)} + \alpha_k(\sum_{i \in S}\sum_{j \in S} x_{ij}^{(k)} - (|S|-1)) \},
\end{equation}
где $x^{(k)}$ — решение релаксированной задачи на $k$-й итерации, 
а $\alpha_k$ — параметр шага субградиентного метода.

Преимущества метода:
\begin{itemize}[label=---]
    \item универсален в использовании, так как является модификацией методов типа ветвей и границ;
    \item исключение сложных ограничений из непосредственного решения ЦЛП позволяет быстрее решать ЗК (решение оценивается примерно в $n^4$ операций).
\end{itemize}

Недостатки метода:
\begin{itemize}[label=---]
    \item найденные решения в ходе Лагранжевой релаксации не обязательно оптимальны для изначальной ЗК;
    \item для больших задач поиск хороших множителей Лагранжа может занимать значительное время [13].
\end{itemize}
%
%
%
\section{Эвристические методы}
Эвристические методы --- это алгоритмические подходы, которые стремятся быстро находить приемлемые, но не обязательно оптимальные решения сложных задач оптимизации, таких как ЗК. В отличие от точных методов, эвристики не гарантируют нахождения оптимального решения, однако позволяют существенно сократить вычислительные затраты и применимы к большим задачам, где точный перебор или сложные оптимизационные процедуры становятся слишком ресурсозатратными или практически невозможными [14].

\subsection{Метод ближайшего соседа}
Идея алгоритма ближайшего соседа основана на простом эвристическом правиле: если мы будем посещать ближайший пункт на каждом шаге, то маршрут получится довольно хорош в целом. Перед коммивояжером ставится задача посещать ближайший из еще не посещенных пунктов. В алгоритме существуют два важных ограничения:
\begin{enumerate}
    \item Недопущение повторного заезда в пункт. Оно связано с
необходимостью (по условию задачи) нахождения гамильтонова цикла, то
есть цикла, в котором все пункты посещаются единожды.
    \item Недопущение возврата преждевременного возврата в исходный
пункт. Этот запрет вводится для предотвращения преждевременного
зацикливания маршрута, которое повлечет за собой неправильную работу
алгоритма.
\end{enumerate}

Схема метода изображена на~\ref{img:nearn}.\clearpage
\imgScale{0.6}{nearn}{Схема метода ближайшего соседа}

Главным преимуществом метода является высокая скорость выполнения. Методу достаточно одного прохода по всем вершинам, в результате чего он работает за время порядка $O(n^2)$ для $n$ городов, что достаточно быстро при относительно небольших $n$, по сравнению с точными методами, рассмотренными выше.

Однако, как было упомянуто раньше, слепое жадное решение может приводить к получению не самого оптимального пути. При этом результат сильно зависит от выбора начального города, так как метод не пересматривает сделанные ранее выборы.

\subsection{Генетический метод}
Генетический алгоритм является алгоритмом поиска, который возможно применить для решения задачи оптимизации. Генетический алгоритм использует методы аналогичные естественному отбору в природе, такие как наследование, мутация, кроссинговер и сам отбор [16].

Для применения генетического алгоритма к ЗК необходимо формализовать основные этапы алгоритма в контексте оптимизации маршрута.
\begin{enumerate}
    \item Целевая функция: Цель --- минимизировать длину тура, которая задается как:
    \begin{equation}
    f(T) = \sum_{i=1}^{n} d(x_i, x_{i+1}),
    \end{equation}
    где \(T = \{x_1, x_2, \dots, x_n, x_1\}\) — маршрут, а \(d(x_i, x_{i+1})\) --- расстояние между городами \(x_i\) и \(x_{i+1}\).
    \item Cоздается начальная популяция:
    \begin{equation}
    P = \{T_1, T_2, \dots, T_m\},
    \end{equation}
    где каждая особь \(T_i\) представляет собой случайный маршрут.
    \item Селекция. Для выбора родителей используется метод рулетки или турнирный отбор. Вероятность выбора маршрута \(T_i\) пропорциональна его приспособленности \(f(T_i)\):
    \begin{equation}
    P(T_i) = \frac{\frac{1}{f(T_i)}}{\sum_{j=1}^{m} \frac{1}{f(T_j)}}.
    \end{equation}
    \item Кроссинговер. Родители \(T_1\) и \(T_2\) комбинируются для получения потомков. Один из подходов — частично сопоставленный кроссинговер (PMX), при котором потомок \(T'\) наследует сегмент маршрута от одного родителя, а оставшиеся элементы берутся из другого.
    \item Мутация. Для увеличения вариативности производится случайное изменение маршрута, например, инверсией случайного сегмента:
    \begin{equation}
    T' = \{x_1, x_2, \dots, x_i, x_j, \dots, x_i, x_{j+1}, \dots, x_n\}.
    \end{equation}
    \item Новая популяция формируется из наиболее приспособленных особей на основе функции \(f(T)\).
    \item Алгоритм завершается, если достигается заданное количество итераций или если улучшение целевой функции становится незначительным.
\end{enumerate}
Экспериментально временная сложность ГА была оценена как $t = 683 - (42,467 · N) + (1,0696 · N^2)$.

Преимущества метода:
\begin{itemize}[label=---]
    \item имеет степенную, а не экспоненциальную сложность;
    \item подходит для любых целевых функций;
    \item хорошо подходит для распараллеливания, так как вычисления для различных особей в популяции независимы.
\end{itemize}

Недостатки метода:
\begin{itemize}[label=---]
    \item метод находит приближенное решение, которое может не быть оптимальным;
    \item эффективность ГА сильно зависит от выбора параметров, таких как размеры популяции, вероятность кроссинговера и мутации.
\end{itemize}

\subsection{Муравьиный алгоритм}
Одним из эвристических методов решения задачи коммивояжера является муравьиный алгоритм. Этот алгоритм имитирует передвижение колонии муравьев в природе.

Выбор города основывается на матрице расстояний \(\{d_{ij}\}\) и использует значение таблицы феромонов \(T\). Феромоны — это некоторое вещество, которое «откладывают» муравьи, помечая лучший маршрут между городами.

Передвижение муравья направляет случайное число, которое отправляет его в город \(k\) с большей вероятностью, если функция \(P_{ij}\) принимает наибольшее значение. 

Вероятность перехода из города \(i\) в \(j\) вычисляется по формуле:
\begin{equation}
P_{ij} = \frac{\tau_{ij}^\alpha \cdot \left( \frac{1}{d_{ij}} \right)^\beta}{\sum_{k \in \text{доступные города}} \tau_{ik}^\alpha \cdot \left( \frac{1}{d_{ik}} \right)^\beta},
\end{equation}
где \(\tau_{ij}\) — феромон между этими городами, \(\frac{1}{d_{ij}}\) — видимость города, а \(\alpha\) и \(\beta\) — коэффициенты, регулирующие решение. 

Если \(\alpha = 0\), то алгоритм становится «жадным», и выбор основывается только на расстоянии между городами, если \(\beta = 0\) — выбор города базируется только на значении феромона.

Получив собственный маршрут для каждого муравья и выбрав наименьший, если полученное решение нас не удовлетворяет, то обновляем таблицу феромонов с учетом «пропозиции» (проходили ли маршрут хотя бы один муравей через это ребро), и строим маршруты заново.

Преимущества метода:
\begin{itemize}[label=---]
    \item феромоны позволяют учитывать накопленный опыт для улучшения качества решений;
    \item подходит для параллельного выполнения, так как муравьи работают независимо друг от друга;
    \item хорошо подходит для распараллеливания, так как вычисления для различных особей в популяции независимы.
\end{itemize}

Недостатки метода:
\begin{itemize}[label=---]
    \item метод предоставляет приближённое решение;
    \item возможна концентрация феромонов на подоптимальных путях, что препятствует дальнейшему поиску;
    \item результаты сильно зависят от настройки параметров $\alpha, \beta$ и скорости испарения феромонов.
\end{itemize}
Модификация с элитными муравьями улучшает базовый муравьиный алгоритм за счет выделения специальных "элитных" муравьев, которые оказывают большее влияние на обновление таблицы феромонов. Эти муравьи следуют наиболее успешным маршрутам, найденным в предыдущих итерациях, и вносят дополнительный вклад в увеличение феромонов на ребрах, принадлежащих этим маршрутам. Подход ускоряет сходимость алгоритма и позволяет концентрировать фокус на оптимальных маршрутах, однако может привести к преждевременной сходимости, если элитные маршруты закрепляются слишком рано.

\subsection{Алгоритм имитации отжига}
Метод имитации отжига основан на моделировании физического процесса закалки металлов, где система постепенно охлаждается, переходя от хаотичного состояния к упорядоченному. Для ЗК это означает нахождение глобального минимума функции, представляющей длину маршрута. На каждой итерации метод генерирует новое решение и оценивает его с помощью энергетической функции \(U(x)\), равной длине текущего маршрута. Если новое решение улучшает \(U(x)\), оно принимается. Если нет, оно принимается с вероятностью 
\begin{equation}
P = \exp\left(-\frac{\Delta U}{T}\right),
\end{equation}
где \(\Delta U\) — разница в длинах маршрутов, а \(T\) — текущая температура. Постепенное снижение \(T\) позволяет алгоритму сначала исследовать большое пространство решений, а затем сосредоточиться на локальных улучшениях.
На рисунке~\ref{img:P} показаны зависимости вероятности мутации от величины \(\Delta U\) при различных значениях температуры $T$.
\imgScale{0.6}{P}{Вероятность мутации для метода имитации отжига}

Высоким температурам соответствуют графики, чей цвет ближе к красному, низким --- к синему. Как и положено, значение вероятности заключено в отрезке $[0;1]$. При отрицательных \(\Delta U\) вероятность равна 1, что соответствует случаю «хорошей» мутации.

Преимущества метода:
\begin{itemize}[label=---]
    \item не требует сложной настройки параметров, кроме кривой охлаждения;
    \item метод легко адаптируется к различным модификациям задачи коммивояжера;
    \item при использовании качественного начального маршрута метод может достичь решения, близкого к оптимальному.
\end{itemize}

Недостатки метода:
\begin{itemize}[label=---]
    \item требуется большое количество итераций для достижения качественного решения;
    \item метод предоставляет приближённое решение.
\end{itemize}

\subsection{Метод роя частиц}
Метод роя частиц моделирует поведение коллективного разума, наблюдаемого в природе, например, в роевом движении птиц или рыб. В контексте ЗК каждая частица представляет возможный маршрут, а рой — множество таких маршрутов. Алгоритм использует два ключевых компонента: личный опыт частицы (лучший маршрут, который она нашла) и коллективный опыт роя (лучший маршрут, найденный всеми частицами). На каждой итерации частицы обновляют свои позиции (маршруты) на основе следующих формул:
\begin{equation}
v_i^{k+1} = w \cdot v_i^k + c_1 \cdot r_1 \cdot (p_i - x_i^k) + c_2 \cdot r_2 \cdot (g - x_i^k),
\end{equation}
\begin{equation}
x_i^{k+1} = x_i^k + v_i^{k+1},
\end{equation}
где \(v_i^k\) — скорость частицы \(i\) на итерации \(k\), \(x_i^k\) — её текущая позиция (маршрут), \(p_i\) — лучший маршрут частицы, \(g\) — глобальный лучший маршрут, а \(w\), \(c_1\), \(c_2\), \(r_1\), \(r_2\) — параметры, управляющие инерцией, обучением от личного и коллективного опыта.

Преимущества метода:
\begin{enumerate}
    \item комбинация личного и коллективного опыта позволяет рою избегать застревания в локальных минимумах;
    \item поддается распараллеливанию, так как частицы работают независимо друг от друга.
\end{enumerate}

Недостатки метода:
\begin{enumerate}
    \item для задач с высоким числом переменных может потребоваться большое количество итераций;
    \item эффективность алгоритма зависит от правильной настройки параметров \(w\), \(c_1\), \(c_2\);
    \item алгоритм требует адаптации для задач, таких как ЗК, где маршруты представляют собой дискретные структуры;
    \item метод предоставляет приближенное решение, которое может не быть оптимальным.
\end{enumerate}

\section{Критерии сравнения}
Для проведения сравнительного анализа методов решения задачи коммивояжера были введены общие критерии:
\begin{enumerate}
    \item Точность решения --- гарантирует ли метод нахождение глобально оптимального маршрута.
    \item Временная сложность --- как быстро метод находит решение в зависимости от размера задачи.
    \item Масштабируемость --- как метод адаптируется к увеличению числа вершин (городов).
    \item Простота реализации — сложность настройки метода для нахождения оптимального маршрута.
    \item Возможность распараллеливания --- позволяет ли метод эффективно использовать параллельные вычисления.
\end{enumerate}
\section{Сравнение методов}
Сравнительный анализ методов по приведенным выше критериям представлен в таблице~\ref{tbl:methods}.

\begin{table}[h!]
\centering
\captionsetup{justification=raggedright,singlelinecheck=off}
\caption{Сравнение методов решения ЗК по критериям}
\label{tbl:methods}
\begin{tabular}{|l|c|l|c|c|c|}
\hline
\textbf{Метод} & \textbf{Точность} & \textbf{Сложность} & \textbf{Масштаб.} & \textbf{Простота} & \textbf{Распарал.} \\
\hline
МПП & +  & $O(n!)$ & $-$ & + & $-$ \\
\hline
МДП & +  & $O(n^2 \cdot 2^n)$ & $-$ & ± & ± \\
\hline
ВГ & +  & $O(2^n)$ & ± & ± & ± \\
\hline
ММЛ & ±  & $O(n^4)$ & ± & $-$ & ± \\
\hline
МБС & $-$ & $O(n^2)$ & + & + & + \\
\hline
ГА & $-$ & $O(n^4)$ & + & ± & + \\
\hline
МА & $-$ & $O(n^4)$ & ± & ± & + \\
\hline
МИО & $-$ & $O(n^3)$ & + & + & ± \\
\hline
МРЧ & $-$ & $O(n^4)$ & + & ± & + \\
\hline
\end{tabular}
\end{table}